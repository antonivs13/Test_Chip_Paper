#!/usr/bin/python
"""This function converts the fault signature of a circuit defect simulation run and convert it to csv format for visualization"""

import os, os.path
from optparse import OptionParser
import string

def main():
	usage = "usage: %prog [options] options."
	version = "%prog 1.0"
	parser = OptionParser(usage=usage, version=version)

	parser.add_option("-f", "--faults", action="append", default = [], dest="faults",
			help="specify the fault models you used to generate the signature file.", metavar="STRING")
	parser.add_option("-s", "--signature", dest="signature",
			help="specify the signature file generated by hashing.py.")
	parser.add_option("-o", "--outfile", dest="outfile",
			help="specify output file to store the converted data in csv format.")
	parser.add_option("--outlier", dest="outlier",
			help="enable outlier analysis: specify path to store outlier fault signature indices. ")
	parser.add_option("-t", "--threshold", dest="threshold",
			help="specify equivaleint fault responses count threshold in the outlier analysis mode", metavar="INT")

	(options, args) = parser.parse_args()

	if options.signature is None or options.outfile is None:
		parser.error("Please specify the signature file and the output file!")

	if options.outlier and options.threshold is None:
		parser.error("Outlier analysis needs a threshold value and an output file path to store the outlier fault signature groups!")

	if len(options.faults) == 0:
		parser.error("Please specify the fault model(s) you used to generate the fault signature file!")

	model_size = len(options.faults)

	# read each line in the signature file and count number of faults in each equivalent fault class
	fault_count = [0] * model_size
	x_axis = []
	sig_size_array = []
	output_array = []
	outlier_array = []
	unique_sig_count = 0
	with open(options.signature, 'r') as infile:
		for line in infile:
			# split the line and ignore the curly brackets
			myFaults = line.split()[1:-1]
			# the last entry of fault_array is the sum of fail log counts across all fault models for the current fault signature
			fault_array = [0] * (model_size+1)
			# print(myFaults)

			# count how many fail logs have the current fault signature and store them based on their fault models
			for n in range(model_size):
				for i in myFaults:
					if options.faults[n] in i:
						fault_count[n] = fault_count[n] + 1
						fault_array[n] = fault_array[n] + 1
			fault_array[-1] = sum(fault_array[:-1])
			x_axis.append(fault_array[-1])
			# print(fault_array)
			# append fault array to sig_size_array
			#sig_size_array.append([])
			sig_size_array.append(fault_array)
			# if options.outlier:
			#	if class_size > int(options.threshold):
			#		outlier_array.append(line)
			unique_sig_count = unique_sig_count + 1
	infile.close()

	# sort sig_size_array according to the last column
	sig_size_array = sorted(sig_size_array, key=lambda l:l[-1])

	# print(sig_size_array)

	# collapse class size array into simplified 2D list: [[signature_group_size_1, count_from_fault_model_1, count_from_fault_model_2, ..., mixed(fail logs from different fault models share the same fault signature)], [signature_group_size_2, count_from_fault_model_1, count_from_fault_model_2, ..., mixed], ...]
	x_axis = list(set(x_axis))

	for i in x_axis:
		output_array.append([])
		output_array[-1] = [0] * (model_size + 2)
		output_array[-1][0] = i
		for j in range(len(sig_size_array)):
			if sig_size_array[j][-1] == i:
				# if only one fault model contributes to this fault signature
				if sig_size_array[j].count(0) == model_size - 1:
					# print(sig_size_array[j])
					# print(sig_size_array[j].index(i))
					output_array[-1][sig_size_array[j].index(i)+1] = output_array[-1][sig_size_array[j].index(i)+1] + 1
				else:
					output_array[-1][-1] = output_array[-1][-1] + 1

	# print(output_array)
	#fault_array = []
	#row = 0
	#class_count = 0
	#for i in range(len(class_size_array)):
		# first item in the array is a special case
	#	if i == 0:
	#		fault_array.append([])
	#		fault_array[row].append(class_size_array[i])
	#		class_count = class_count + 1
		# start new row and reset class count
	#	elif class_size_array[i] != class_size_array[i-1]:
	#		fault_array[row].append(class_count)
	#		fault_array.append([])
	#		row = row + 1
	#		fault_array[row].append(class_size_array[i])
	#		class_count = 1
	#	elif class_size_array[i] == class_size_array[i-1]:
	#		class_count = class_count + 1

		# last item in the array is another special case
	#	if i == len(class_size_array) - 1:
	#		fault_array[row].append(class_count)


	# write fault array to output file in csv format
	with open(options.outfile, 'w') as outfile:
		#outfile.write("Number of equivalent faults;count\n")
		for i in range(len(output_array)):
			for j in range(len(output_array[0])):
				outfile.write(str(output_array[i][j]) + ",")
			outfile.write(str(output_array[i][0] * sum(output_array[i][1:])) + '\n')
	outfile.close()

	print("There were " + str(fault_count) + " fail logs corresponding to the fault models " + str(options.faults) + '.')
	print("There were " + str(unique_sig_count) + " unique fault signatures.")

if __name__ == '__main__':
	main()
